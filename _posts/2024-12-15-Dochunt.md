---
title:  "DocHunt: A Multi-Language Hack to Migrate Kipwise Documentation"

categories:
    - Blog
tags:
    - Documentation
    - Recursion
layout: page
permalink: /blog/dochunt/
---


In the ever-evolving landscape of software development, maintaining documentation is crucial, but the tools we use to manage it can become outdated or expensive. This is the story of how we successfully migrated thousands of documents from Kipwise to plain Markdown, using a custom-built solution, and in the process, saved Recursion ~$15k USD per year! üí∞üí∞


## The Challenge

Our company had accumulated nearly **2,000 documents across 466 subdirectories** in Kipwise, a documentation platform that was costing us approximately $15,000 per year. The challenge was clear: we needed to migrate all this content to a simpler, more cost-effective solution while maintaining the hierarchical structure and formatting of our documentation.

While Kipwise served us well for a time, it came with a hefty annual bill and had started to feel like a closed box-limited in customizability and difficult to version control. To make things trickier, Kipwise doesn‚Äôt expose a public REST API‚Äîat least not one we could find.

**So we asked: Can we bring these docs to plain markdown to plug to our in-house docs even though Kipwise was hiding the API? ü•Å**
<br> Turns out, we could. üòé


## The Solution: A Multi-Language Approach

To tackle the migration, I built **DocHunt** as a combination of JavaScript, Bash, and Python scripts.

![DocHunt Architecture](/assets/images/dochunt.png){: width="25%"}

Let's break it down.

### 1. Expanding the Tree with expand.js

We started in the browser. I found out Kipwise actually have one REST API under the hood, and it I could find it after some wizardry using the inspect tool. I also identified that Kipwise lazily loads its document tree, so we had to make sure all nodes were expanded before we could scrape URLs.

<details>
<summary>Expand Tree Nodes JavaScript Code</summary>

<pre><code class="language-js">
function expandTreeNodes() {
    const nodesToClick = document.querySelectorAll('span.cOnmID.Icon--caret-right--2jLJYkxd');
    if (nodesToClick.length === 0) return console.log("All nodes expanded");

    nodesToClick.forEach(node => {
        let ancestor = node;
        for (let i = 0; i < 3; i++) ancestor = ancestor.parentElement;
        console.log("Expanding:", ancestor.innerText.trim());
        node.click();
    });
    setTimeout(expandTreeNodes, 100); // loop until all are expanded
}
expandTreeNodes();
</code></pre>

</details>
<br>
I ran this in the browser console while viewing the Kipwise docs tree. With this step I expand all nodes in the Kipwise UI tree and make sure no documents are left hidden.

### 2. Extracting Document URLs

Once everything was visible, we ran another script to extract all document URLs and metadata from the Document Object Model (DOM). The DOM is a programming interface used by web browsers to represent and interact with the structure of an HTML or XML document. Since it exposes the content of the page (like elements, attributes, and text) as a tree of objects that JavaScript can access and manipulate, we take advanatge of it:

<details>
<summary> Extract document URL </summary>

<pre><code class="language-js">
const links = document.querySelectorAll('a[href]');
const results = [];

links.forEach(link => {
    const folderId = link.getAttribute('folderid');
    const href = link.getAttribute('href');
    const match = href?.match(/\/contents\/([a-f0-9\-]{36})/);

    if (folderId && match) {
        const title = link.innerText.trim();
        const url = `https://webapi.kipwise.com/1.0/documents/${match[1]}/`;
        results.push(`${folderId} ${url} ${title}`);
    }
});
console.log(results.join('\n'));
</code></pre>

</details>
<br>
This gave us a raw list of folder UUIDs, document URLs, and titles. Here, I am scrapping titles and URLs
while preserves the directory hierarchy.




### 3. Downloading JSON

Now that we have the doc page URLs, we used curl to fetch the content of each doc via Kipwise's undocumented internal API:

<details>

<summary> Curl and get the <code>.json</code>! </summary>

<pre><code class="language-bash">
#!/bin/bash
input_file="raw_output.txt"
output_dir="./output_json/"
mkdir -p "$output_dir"

while read -r line; do
  url=$(echo "$line" | awk '{print $2}')
  output_file="$output_dir/$(basename "$url").json"
  echo "Fetching: $url"
  curl "$url" \
    -H "x-kip-token: YOUR_TOKEN" \
    -H "x-team-id: YOUR_TEAM_ID" \
    -H "Accept: application/json" > "$output_file"
  sleep 2
done < "$input_file"
</code></pre>

</details>
<br>
By fetching the JSON files associated with each do page and saving to disk, we preserve the original strcuture.

### 4. Converting JSON to Markdown

The Kipwise API returns deeply nested JSON, so we built a converter that handles headings, bold text, paragraphs, lists, and even links:

<details>

<summary>Convert <code>.json</code> to <code>.md</code></summary>

<pre><code class="language-python">
def format_text(leaves):
    return "".join("**" + l["text"] + "**" if "marks" in l and any(m["type"] == "strong" for m in l["marks"]) else l["text"] for l in leaves)

def format_markdown(node):
    t = node.get("type", "")
    if t == "title": return f"# {format_text(node['nodes'][0]['leaves'])}"
    if t == "heading-two": return f"## {format_text(node['nodes'][0]['leaves'])}"
    if t == "paragraph":
        return "".join(format_text(c["leaves"]) if c["object"] == "text" else f"[{format_text(c['nodes'][0]['leaves'])}]({c['data']['href']})" for c in node.get("nodes", []))
    if t == "list-item": return f"- {''.join(format_markdown(c) for c in node['nodes'])}\n"
    # Fallback
    return "".join(format_markdown(child) for child in node.get("nodes", []))
</code></pre>
</details>
<br>
This step converts rich text blocks to Markdown and handles links, headings, bullets, and special characters. Very important in our docs!


### 5. Batch Conversion

Since we had __a lot__ of files, we needed a way to scale the conversion. This script batch-processed everything and logged any errors for review. It's essentially a wrapper that ran the converter on all JSON files:

<details>

<summary>Convert <code>.json</code> to <code>.md</code></summary>

<pre><code class="language-python">
for filename in os.listdir(input_dir):
    if filename.endswith('.json'):
        subprocess.run(
            ['python', 'json_to_markdown.py'],
            stdin=open(os.path.join(input_dir, filename), 'r'),
            stdout=open(os.path.join(output_dir, filename.replace('.json', '.md')), 'w')
        )
</code></pre>
</details>
<br>
Converts in parallel and reports failures and inconsistencies.

### 6. Rebuilding the Folder Structure

Finally, we rebuilt the folder hierarchy using the original Kipwise structure stored in a JSON mapping. Each file was renamed and moved accordingly:

```python
def clean_filename(name):
    return re.sub(r'[^\w\-_.]', '', name.replace(' ', '_'))

def create_directory_structure(...):
    # Load folder UUID mappings
    with open(folders_json) as f:
        folders = json.load(f)
    ...
    for line in open(raw_output_file):
        folder_uuid, url, title = parse_line(line)
        folder_path = folders.get(folder_uuid)
        dest_dir = os.path.join(full_output_dir, *map(clean_filename, folder_path))
        os.makedirs(dest_dir, exist_ok=True)

        uuid = extract_uuid(url)
        src_file = os.path.join(output_base_dir, f"{uuid}.md")
        dest_file = os.path.join(dest_dir, f"{clean_filename(title)}.md")
        shutil.copyfile(src_file, dest_file)
```


## Results
- üìÑ **Migrated:** 1,978 files
- üìÅ **Subdirectories preserved:** 466
- üíæ **Final size:** ~11MB of Markdown
- üí∞ **Cost savings:** $15,000/year

We ended up with a new, Git-friendly documentation system organized by topics like development, Discovery Platform, among many others.


## Lessons Learned
- Don‚Äôt fear migration projects! They can be fun and impactful üìà
- Start simple, then scale. ‚¨ÜÔ∏è
- Having logs at every step saved us during debugging! üêõ
- Markdown is a surprisingly powerful yet simple documentation format. üìÉ
- Cost-saving side projects can build momentum and trust! üí∞

## Conclusion

This project started as a cost-saving initiative but ended up delivering much more: autonomy over our documentation, better version control, and simpler backups. By stitching together browser scripts, shell tools, and Python logic, we built a lean pipeline to take our knowledge back from a locked-down SaaS and into our own version-controlled hands.

If you're stuck with costly platforms for something as fundamental as documentation, it might be time to plan your own hunt.